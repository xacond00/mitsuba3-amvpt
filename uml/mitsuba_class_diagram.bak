@startuml

abstract class Integrator {
    - m_stop : bool
    - m_timeout : float
    - m_render_timer : Timer
    - m_hide_emitters : bool
    - m_id : string
    + *render(Scene, Sensor)* : TensorXf
    + *render_forward(Scene, void*, Sensor)* : TensorXf
    + *render_backward(Scene, void*, TensorXf, Sensor)* : void
    + cancel() : void
    + should_stop() : bool
    + aov_names() : vector<string>
    + id() : string
    + set_id(string) : void
}

abstract class SamplingIntegrator {
    - m_block_size : uint32_t
    - m_samples_per_pass : uint32_t
    + render(Scene, Sensor) : TensorXf
    + sample(Scene, Sampler, RayDifferential3f, Medium, Float*, Mask) : pair<Spectrum, Mask>
    + render_block(Scene, Sensor, Sampler, ImageBlock, Float*, uint32_t, uint32_t, uint32_t) : void
    + render_sample(Scene, Sensor, Sampler, ImageBlock, Float*, Vector2f, ScalarFloat, Mask) : void
}

abstract class MonteCarloIntegrator {
    - m_max_depth : uint32_t
    - m_rr_depth : uint32_t
}

abstract class AdjointIntegrator {
    - m_samples_per_pass : uint32_t
    - m_max_depth : int
    - m_rr_depth : int
    + sample(Scene, Sensor, Sampler, ImageBlock, ScalarFloat) : void
}

abstract class Shape {
    - m_bsdf : ref<BSDF>
    - m_emitter : ref<Emitter>
    - m_sensor : ref<Sensor>
    - m_interior_medium : ref<Medium>
    - m_exterior_medium : ref<Medium>
    + is_sensor() : bool
    + is_mesh() : bool
    + ray_test() : bool
    + sample_direction(Interaction3f, Point2f, Mask) : DirectionSample3f
}

abstract class Endpoint {
    - m_shape : Shape*
    + sample_ray(Float, Float, Point2f, Point2f, Mask) : pair<Ray3f, Spectrum>
    + set_scene(const Scene*) : void
}

abstract class Sensor {
    - m_film : ref<Film>
    - m_sampler : ref<Sampler>
    - m_resolution : ScalarVector2f
    + sample_ray(Float, Float, Point2f, Point2f, Mask) : pair<Ray3f, Spectrum>
    + sample_direction(ref<Interaction3f>, Point2f, Mask) : pair<DirectionSample3f, Spectrum>
}

class Scene {
    - m_shapes : vector<ref<Shape>>
    - m_sensors : vector<ref<Sensor>>
    - m_integrator : ref<Integrator>
    + ray_test(Ray3f, Mask) : Mask
    + ray_intersect(Ray3f, uint32_t, Mask, Mask) : SurfaceInteraction3f
}

class BSDF {
    - m_id : string
    - m_flags : uint32_t
    - m_components : uint32_t
    + eval_diffuse_reflectance(SurfaceInteraction3f) : Spectrum
    + eval_attribute_1(SurfaceInteraction3f, bool) : Float
    + flags(uint32_t) : uint32_t
}

BSDF <|-- Shape : "has" as H1 

Scene "1" --> "0..*" Shape : has
Scene "1" --> "0..*" Sensor : has
Scene "1" --> "0..1" Integrator : uses

Sensor -|> Endpoint : overrides sample_ray, sample_direction

Endpoint "1" --> "0..1" Shape : has
Integrator <|-- SamplingIntegrator
SamplingIntegrator <|-- MonteCarloIntegrator
Integrator <|-- AdjointIntegrator

@enduml
